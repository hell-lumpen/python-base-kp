# Курсовой проект. Техническое задание

Проект основан на реализации **паттерна "Цепочка обязанностей"** для обработки этапов анализа данных (EDA — Exploratory Data Analysis) с использованием Python. Цель проекта — создать цепочку обработчиков, которые поочередно выполняют различные шаги в анализе данных (например, загрузка, очистка, анализ и визуализация), и все эти шаги можно комбинировать и выполнять через последовательность действий.

1. Ознакомление с материалами:
    - Прочитать предоставленную документацию и понять структуру проекта.
    - Скопировать и сохранить весь код из предоставленного приложения на Python. Ссылка на github с проектов лежит в LMS. Выполнять работу можно как локально, в Pycharm и аналогичных IDE (инструкции по запуску как раз написаны для них), так и используя Google Colab или JetBrains Datalore.
    - Разобрать используемые принципы ООП, стандартную библиотеку ``abc`` и паттерн "Цепочка обязанностей" на основе примера.
  
2. Загрузка данных:
    - Перейти на Kaggle.
    - Скачайте любой интересующий вас датасет в формате CSV (например, датасет о ценах на жилье, медицинские данные, данные о погоде и так далее).

3. Изменение конфигурации:
    - Найти файл ``config.json`` в проекте.
    - Изменить значение пути в конфиге: в поле ``datasets_dir`` указать путь к папке с датасетом.
    - В поле ``file_name`` указать название вашего датасета.

4. Запуск приложения:
    - Запустите приложение.
    - Убедитесь, что программа правильно загружает, очищает данные и генерирует отчет.

5. Результат работы:
    - В результате работы приложения должен быть сгенерирован отчет в формате HTML с помощью библиотеки ``sweetviz``.
    - Приложение также должно очистить данные, убрав дубликаты и пропуски.

Ожидаемый результат:

Программа должна правильно работать и генерировать отчеты по заданному датасету. Программа должна запускаться без ошибок на Python 3.x. (обратите внимание на тонкости использования ``sweetviz`` на новых версиях python, об этом сказано подробно в описании библиотеки ниже).

По результатам выполнения необходимо написать отчет о курсовом проекте следующего содержания:

1. Цель курсового проекта. 
2. Постановка задачи 
3. Описание и источник датасета (можно и нужно для этого использовать отчет ``sweetviz``)
4. Описание паттерна Цепочка обязанностей и того, как он реализован в приложении
5. Описание каждого реализованного этапа EDA анализа.
6. Вывод 

Обязательно необходима ссылка на ноутбук с реализацией задачи.

**Сроки выполнения: 15 января 19:00**

Шаблон отчета по курсовому проекту лежит в LMS в курсе по Python.

---

# Документация по проекту

## Основные компоненты проекта

### Библиотеки, используемые в проекте

В этом проекте используется несколько популярных библиотек, каждая из которых играет свою роль в обработке данных и создании визуализаций. Давайте подробно рассмотрим каждую из них.

#### 1. **Pandas**
**Pandas** — это библиотека для работы с данными в Python, которая предоставляет эффективные структуры данных, такие как `DataFrame` и `Series`, для хранения и манипуляции табличными данными.

- **Основное использование:** 
    - Загружать, обрабатывать и анализировать данные в формате табличных данных.
    - Очистка данных: удаление дубликатов, замена пропусков.
    - Агрегация и статистический анализ данных.

В нашем проекте используется `pandas` для загрузки CSV-файлов с данными (например, с помощью `pd.read_csv`), их очистки и дальнейшей обработки перед анализом и визуализацией.

#### 2. **Sweetviz**
**Sweetviz** — это библиотека для автоматической визуализации и анализа данных. Она генерирует подробные отчеты в формате HTML, в которых представлена статистика по данным, графики распределений, корреляции и многие другие визуализации.

- **Основное использование:** 
    - Автоматическое создание детализированных отчетов с визуализациями.
    - Представление статистики по каждому столбцу, корреляция между признаками.
    - Вывод HTML отчета, который можно легко открыть в браузере для дальнейшего анализа.

В этом проекте используется **Sweetviz** для генерации отчетов по данным с графиками и статистикой. Отчеты помогают глубже понять структуру данных и выявить важные зависимости.

**Дополнение по Sweetviz:**  
При использовании `Sweetviz`, пользователи могут столкнуться с ошибками, связанными с зависимостью от определенной версии библиотеки `numpy`. Один из таких случаев проявляется в виде ошибки `AttributeError: module 'numpy' has no attribute 'VisibleDeprecationWarning'`, если версия numpy не поддерживает атрибут `VisibleDeprecationWarning`.

Чтобы решить эту проблему, можно вручную изменить код библиотеки. Найдите строку в файле `sweetviz/graph_numeric.py`:
```python
warnings.filterwarnings('ignore', category=np.VisibleDeprecationWarning)
```

И замените на:
```python
warnings.filterwarnings('ignore', category=Warning)
```

Эта замена позволит игнорировать все виды предупреждений, а не только предупреждения, связанные с устаревшими депрецированными методами, которые вызывает numpy. Это решит проблему с несовместимостью версий `numpy`.

#### 3. **Setuptools**
**Setuptools** — это инструмент для создания, упаковки и распространения Python-библиотек. Он облегчает установку и управление зависимостями.

- **Основное использование:** 
    - Упаковка Python-проектов для установки и распространения.
    - Управление зависимостями, создание исполнимых файлов.

- **Как она работает в проекте:** В данном проекте библиотека `setuptools` используется для упрощения установки зависимостей, таких как `sweetviz`. Это гарантирует, что нужные пакеты будут корректно установлены, независимо от среды пользователя.

### Принцип работы

1. **Абстрактный базовый класс `Handler`** — это основа для всех обработчиков в цепочке. Этот класс реализует структуру обработки данных, передавая их от одного обработчика к другому в случае успеха.
2. **Конкретные обработчики** — каждый обработчик реализует отдельный этап работы с данными.
3. **Цепочка обязанностей (Chain of Responsibility)** — цепочка обработчиков, которые выполняют действия с данными по порядку.
4. **Конфигурационный файл** (например, в формате JSON), который управляет настройками для обработки (например, путь к файлу данных, директория для сохранения отчетов).

### Описание классов и их обязанностей

### 1. Класс `Handler` (Базовый класс)

```python
class Handler(ABC):
    def __init__(self, next_handler=None):
        self.next_handler = next_handler

    def set_next(self, handler):
        """Устанавливает следующий обработчик в цепочке."""
        self.next_handler = handler
        return handler

    @abstractmethod
    def handle(self, data):
        """Обрабатывает данные и передает их следующему обработчику."""
        if self.next_handler:
            return self.next_handler.handle(data)
        return data
```

Этот класс определяет структуру всех обработчиков. Он предоставляет метод `set_next`, который устанавливает следующий обработчик в цепочке, и метод `handle`, который обрабатывает данные и передает их далее по цепочке.

#### Как это работает:
- Каждый обработчик может либо обрабатывать данные, либо передавать их следующему обработчику.
- Класс `Handler` является абстрактным и требует реализации в подклассах метода `handle`.

### 2. Класс `OpenCsvHandler` (Открытие CSV файла)

```python
class OpenCsvHandler(Handler):
    def __init__(self, file_path, file_name):
        super().__init__()
        self.file_path = file_path
        self.file_name = file_name

    def handle(self, data):
        # Чтение CSV файла
        dataset_path = os.path.join(self.file_path, self.file_name)
        if not os.path.exists(dataset_path):
            raise FileNotFoundError(f"Файл {self.file_name} не найден по пути {self.file_path}.")
        logging.info(f"Чтение данных из файла {self.file_name}...")
        data["df"] = pd.read_csv(dataset_path)
        logging.info("Данные успешно загружены.")
        return super().handle(data)
```

Этот обработчик отвечает за открытие CSV файла и загрузку данных в DataFrame (`pd.read_csv`) из указанного пути. После загрузки данных он передает управление следующему обработчику.

#### Как это работает:
- Получает путь и имя файла (передаваются в конфигурации).
- Загружает CSV файл в объект `DataFrame`.
- Передает данные следующему обработчику.

### 3. Класс `CleanDataHandler` (Очистка данных)

```python
class CleanDataHandler(Handler):
    def handle(self, data):
        df = data.get("df")
        if df is None:
            raise ValueError("Данные отсутствуют для обработки.")

        # Очистка данных: удаление дублей и обработка пропусков
        logging.info("Удаление дублей...")
        df.drop_duplicates(inplace=True)

        logging.info("Обработка пропусков...")
        for col in df.columns:
            if df[col].isnull().any():
                if df[col].dtype == 'object':
                    df[col].fillna(df[col].mode()[0], inplace=True)
                else:
                    df[col].fillna(df[col].median(), inplace=True)

        data["df"] = df
        logging.info("Данные очищены.")
        return super().handle(data)
```

Этот обработчик занимается очисткой данных. Он удаляет дублирующиеся строки и обрабатывает пропущенные значения. Если столбец содержит пропуски, он заполняет их значениями по умолчанию (мода для строковых данных и медиана для числовых).

#### Как это работает:
- Получает `DataFrame` из предыдущего обработчика.
- Очищает данные (удаляет дубли, заполняет пропуски).
- Передает очищенные данные следующему обработчику.

### 4. Класс `SweetvizHandler` (Генерация отчета с Sweetviz)

```python
class SweetvizHandler(Handler):
    def __init__(self, output_dir):
        super().__init__()
        self.output_dir = output_dir
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def handle(self, data):
        df = data.get("df")
        if df is None:
            raise ValueError("Нет данных для создания отчета Sweetviz.")

        # Генерация отчета Sweetviz
        logging.info("Генерация отчета Sweetviz...")
        report_path = os.path.join(self.output_dir, "sweetviz_report.html")
        report = sv.analyze(df)
        report.show_html(filepath=report_path)
        logging.info(f"Отчет Sweetviz сохранен: {report_path}")
        return super().handle(data)
```

Этот обработчик создает отчет с помощью библиотеки **Sweetviz**, которая предоставляет визуализацию статистики данных, включая распределение признаков, корреляцию и т.д. Отчет сохраняется в указанный каталог в формате HTML.

#### Как это работает:
- Получает `DataFrame` с данными.
- Генерирует отчет Sweetviz и сохраняет его в виде HTML файла.
- Передает данные следующему обработчику (если он есть).

### 5. Класс `EDAFlow` (Управление цепочкой обязанностей)

```python
class EDAFlow:
    def __init__(self, config):
        self.config = config
        self.chain = None

    def build_chain(self):
        # Создание цепочки обработчиков
        self.chain = OpenCsvHandler(
            file_path=self.config["datasets_dir"],
            file_name=self.config["file_name"]
        )
        self.chain.set_next(CleanDataHandler()) \
                  .set_next(SweetvizHandler(output_dir=self.config["output_dir"]))

    def execute(self):
        if self.chain is None:
            raise RuntimeError("Цепочка не была построена.")
        logging.info("Начало выполнения цепочки анализа данных.")
        self.chain.handle(data={})
```

Класс `EDAFlow` управляет всей цепочкой обработчиков. Он строит цепочку с помощью метода `build_chain` и затем запускает выполнение с помощью метода `execute`. Цепочка состоит из трех этапов: чтение данных, очистка данных, создание отчета.

#### Как это работает:
- Инициализируется цепочка с обработчиками.
- Каждый обработчик выполняет свою задачу и передает данные дальше.
- Когда все обработчики выполнены, работа считается завершенной.

### 6. Функция `main`

```python
def main(config_path: str):
    # Загрузка конфигурации
    with open(config_path, 'r') as f:
        config = json.load(f)

    # Построение и выполнение EDAFlow
    eda_flow = EDAFlow(config)
    eda_flow.build_chain()
    eda_flow.execute()
```

Главная функция, которая запускает процесс. Она загружает конфигурацию из JSON-файла и затем создает и выполняет цепочку обязанностей.

### Как работает проект:

1. В конфигурационном файле (например, `config.json`) содержатся настройки для обработки данных, такие как путь к файлу CSV, директория для сохранения отчетов и т.д.
2. Через объект `EDAFlow` строится цепочка обязанностей.
3. Цепочка начинается с загрузки данных из CSV файла, затем очищается, и, наконец, генерируется отчет.
4. Каждый обработчик выполняет свою задачу и передает управление следующему.

Пример структуры конфигурационного файла:
```json
{
    "datasets_dir": "./datasets",
    "file_name": "housing_data.csv",
    "output_dir": "./reports"
}
```

Проект позволяет строить гибкие процессы анализа данных, где каждый шаг (обработчик) можно легко адаптировать или добавлять новые этапы без изменения логики других частей процесса.

А теперь немного теории...

**Объектно-ориентированное программирование** (ООП) в Python — это подход, который предполагает использование объектов (инстанций классов), где каждый объект может иметь состояния (поля) и методы (функции), которые с этими состояниями взаимодействуют.

В ООП важны следующие концепции:

- **Классы и объекты**:
  - Класс — это шаблон для создания объектов. Он определяет, какие данные будут храниться и какие действия можно выполнить с этими данными.
  - Объект — это экземпляр класса, который содержит конкретные данные.

- **Наследование**:
  - Это механизм, при котором класс может наследовать методы и свойства другого класса.

- **Инкапсуляция**:
  - Скрытие данных и ограничение доступа к ним. Это позволяет контролировать, как данные изменяются и используются.

- **Полиморфизм**:
  - Способность объектов разных классов реагировать на одинаковые вызовы методов с различными реализациями.

Для создания базового класса и наследования в Python используется следующий синтаксис:

```python
class Animal:
    def speak(self):
        print("Animal speaking")

class Dog(Animal):
    def speak(self):
        print("Bark!")

dog = Dog()
dog.speak()  # Вывод: Bark!
```

#### 2. Паттерн "Цепочка обязанностей"

**Цепочка обязанностей (Chain of Responsibility)** — это поведенческий паттерн проектирования, который позволяет избежать жесткой привязки отправителя запроса к получателям. Вместо того чтобы передавать запрос конкретному объекту, запрос передается по цепочке обработчиков, и каждый обработчик решает, обработает ли он запрос или передаст его следующему обработчику.

##### Основная идея:
- Объекты, которые принадлежат цепочке, могут работать с запросами, но каждый из них решает, делать ли это самостоятельно или передать запрос следующему объекту в цепочке.
- Это позволяет централизованно управлять различными операциями обработки, избегая жесткой привязки между отправителями и получателями.

### Применение в Python

Для реализации паттерна в Python мы используем:
- Абстрактные классы для создания общего интерфейса.
- Наследование для создания разных типов обработчиков.
- Связь обработчиков с помощью ссылок на следующий объект.

Пример реализации паттерна "Цепочка обязанностей" в Python:

```python
from abc import ABC, abstractmethod

class Handler(ABC):
    """
    Абстрактный базовый класс для всех обработчиков.
    """
    def __init__(self, next_handler=None):
        self.next_handler = next_handler

    def set_next(self, handler):
        """Устанавливает следующий обработчик в цепочке."""
        self.next_handler = handler
        return handler

    @abstractmethod
    def handle(self, data):
        """Обрабатывает данные и передает их следующему обработчику."""
        if self.next_handler:
            return self.next_handler.handle(data)
        return data

class HandlerA(Handler):
    def handle(self, data):
        if "A" in data:
            print("HandlerA обработал данные!")
            return data
        return super().handle(data)

class HandlerB(Handler):
    def handle(self, data):
        if "B" in data:
            print("HandlerB обработал данные!")
            return data
        return super().handle(data)

class HandlerC(Handler):
    def handle(self, data):
        if "C" in data:
            print("HandlerC обработал данные!")
            return data
        return super().handle(data)

# Пример использования цепочки
handler_a = HandlerA()
handler_b = HandlerB()
handler_c = HandlerC()

handler_a.set_next(handler_b).set_next(handler_c)

# Запускаем цепочку с данными
handler_a.handle("A")  # Вывод: HandlerA обработал данные!
handler_a.handle("B")  # Вывод: HandlerB обработал данные!
handler_a.handle("C")  # Вывод: HandlerC обработал данные!
handler_a.handle("D")  # Нет обработки, так как нет подходящего обработчика
```

### Про abc

`abc` — стандартная библиотека Python, используемый для работы с **абстрактными базовыми классами** (ABC — **Abstract Base Class**).

### Пояснение каждого элемента:

1. **`ABC`**:
   - **ABC (Abstract Base Class)** — это базовый класс, который позволяет определять абстрактные классы в Python. Абстрактные классы не могут быть инстанцированы (т.е., нельзя создать экземпляр абстрактного класса напрямую), но их можно использовать как шаблоны для других классов.
   - Абстрактные классы обычно включают абстрактные методы, которые должны быть реализованы в подклассах. Они помогают задать общий интерфейс для всех классов, которые будут от них наследоваться.

   Пример:

   ```python
   from abc import ABC, abstractmethod

   class Animal(ABC):
       @abstractmethod
       def sound(self):
           pass  # Этот метод должен быть реализован в подклассах

   class Dog(Animal):
       def sound(self):
           return "Bark"

   dog = Dog()
   print(dog.sound())  # Вывод: Bark
   ```

   В этом примере класс `Animal` — абстрактный, а метод `sound` является абстрактным, требуя реализации в каждом подклассе.

2. **`abstractmethod`**:

Опять немного теории...

**Декораторы в Python** — это специальные функции, которые позволяют изменять поведение других функций или методов, не изменяя их исходный код.

Представьте, что у вас есть функция, и вы хотите добавить к ней дополнительные действия, но без изменений в самой функции. Для этого и используются декораторы. По сути, декоратор "оборачивает" функцию, добавляя ей новую функциональность.

Как это работает:
Функция-декоратор: Это функция, которая принимает другую функцию как аргумент и возвращает новую функцию с расширенной функциональностью.
Оборачивание функции: Вместо того, чтобы вызывать функцию напрямую, ты применяешь декоратор, который сначала выполняет какую-то работу (например, до или после вызова самой функции), а затем передает управление основной функции.

   - Это декоратор, который используется для пометки метода как абстрактного. Метод, помеченный как `abstractmethod`, не имеет реализации в абстрактном классе и должен быть обязательно переопределен в подклассе.
   - Метод с этим декоратором не может быть вызван без реализации в классе-потомке.

   Пример с использованием `abstractmethod`:

   ```python
   from abc import ABC, abstractmethod

   class Shape(ABC):
       @abstractmethod
       def area(self):
           pass  # Этот метод должен быть переопределен в подклассах

   class Circle(Shape):
       def __init__(self, radius):
           self.radius = radius

       def area(self):
           return 3.14 * self.radius * self.radius

   circle = Circle(5)
   print(circle.area())  # Вывод: 78.5
   ```

   Здесь класс `Shape` является абстрактным, и метод `area` должен быть реализован в конкретных формах (например, в `Circle`).

### Зачем использовать `ABC` и `abstractmethod`?

- **Чистота кода**: Абстрактные классы и методы помогают создать чистую архитектуру, где все классы строго следуют заданному интерфейсу.
- **Ясность и предсказуемость**: Если класс наследует абстрактный класс, это четко показывает, что этот класс должен реализовать все абстрактные методы.
- **Предотвращение ошибок**: Python не позволит создать объект абстрактного класса, или если абстрактный метод не реализован в дочернем классе, это вызовет ошибку. Таким образом, этот механизм защищает от ошибок на этапе разработки.

### Пример ошибки, если не реализовать абстрактный метод:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    # Методы 'area' не переопределены
    pass

# Ошибка: TypeError: Can't instantiate abstract class Rectangle with abstract methods area
rectangle = Rectangle()
```

В этом случае Python выбросит исключение `TypeError`, потому что метод `area` не был реализован в классе `Rectangle`.

#### 3. Принцип работы

1. **Создание цепочки обработчиков**: Каждый обработчик имеет ссылку на следующий обработчик в цепочке, который будет выполнять действия, если текущий обработчик не может обработать запрос.

2. **Передача запроса**: Когда поступает запрос (или данные для обработки), запрос передается первому обработчику в цепочке.
   - Если обработчик может обработать запрос, он это делает и заканчивает обработку.
   - Если обработчик не может обработать запрос, он передает его следующему обработчику в цепочке.

3. **Обработка данных**: Цепочка продолжается, пока не будет найден обработчик, который способен обработать запрос, или пока не будет достигнут конец цепочки.

#### 4. Преимущества паттерна "Цепочка обязанностей"
- **Гибкость**: Этот паттерн позволяет легко добавлять новые обработчики или изменять порядок их выполнения.
- **Уменьшение зависимости между объектами**: Клиентский код не нуждается в прямой привязке к конкретным обработчикам, что снижает зависимость между компонентами.
- **Легкость модификаций**: Можно изменить поведение обработки данных путем добавления новых обработчиков или изменения логики существующих.

#### 5. Недостатки
- **Может привести к сложным цепочкам**: Если обработчиков слишком много, это может сделать код трудным для отладки и тестирования.
- **Невозможно предусмотреть все возможные случаи**: Если цепочка не покрывает все ситуации, возникнет "пробел" в обработке.

---

#### Пример использования в реальных задачах

1. **Обработка данных**: Паттерн может использоваться для обработки данных в разных форматах (например, CSV, JSON) с дополнительными этапами, такими как очистка данных, анонимизация, проверка целостности и т. д.
   
2. **Обработка ошибок**: Это полезный паттерн для обработки ошибок, когда разные обработчики могут реагировать на различные типы ошибок, передавая их далее по цепочке, если ошибка не решена.

3. **Работа с запросами**: Паттерн может быть применим к обработке HTTP-запросов, где каждый промежуточный компонент (например, маршрутизатор, фильтр, обработчик) может решить, обрабатывать ли запрос или передавать его следующему компоненту.

---

Паттерн "Цепочка обязанностей" помогает делегировать задачи между различными объектами, таким образом, не делая их зависимыми друг от друга. Он делает программу более гибкой и расширяемой, что очень удобно в проектировании сложных систем.

## Запуск приложения

Для простого разворачивания Python-приложения нужно правильно настроить виртуальное окружение и зависимости, чтобы избежать конфликтов версий библиотек и правильно передать конфигурацию. Разберем основные компоненты:

### 1. **Что такое `venv`**

**`venv`** — это инструмент для создания виртуальных окружений в Python. Виртуальное окружение позволяет изолировать проект и его зависимости от других проектов, чтобы гарантировать совместимость и независимость версий пакетов, используемых в разных приложениях.

Простой процесс создания виртуального окружения выглядит так:

- **Шаг 1:** Создайте виртуальное окружение:
    ```bash
    python3 -m venv myenv
    ```

- **Шаг 2:** Активируйте виртуальное окружение:

    - На Windows:
      ```bash
      myenv\Scripts\activate
      ```
    - На macOS или Linux:
      ```bash
      source myenv/bin/activate
      ```

- **Шаг 3:** Установите необходимые зависимости для вашего проекта через `pip` (мы расскажем об этом далее).

### 2. **Что такое `pip` и `pip install -r requirements.txt`**

**`pip`** — это стандартный менеджер пакетов в Python, который позволяет устанавливать библиотеки и пакеты. В сочетании с виртуальным окружением **`pip`** позволяет изолировать все зависимости для проекта, а не использовать глобальную установку Python.

Чтобы установить необходимые зависимости для проекта из файла `requirements.txt`, используется команда:

```bash
pip install -r requirements.txt
```

**Что делает эта команда:**
- **`pip`** считывает файл **`requirements.txt`** и устанавливает все библиотеки, перечисленные в нем.
- Это гарантирует, что в проекте будут установлены именно те версии библиотек, которые необходимы для его работы.

Пример содержимого **`requirements.txt`**:
```
pandas==2.0.1
sweetviz==2.0.2
matplotlib==3.7.1
```

Это означает, что для проекта нужно установить точно указанные версии этих библиотек.

### 3. **Что такое `config.json`**

**`config.json`** — это файл конфигурации в формате JSON, который используется для хранения переменных и настроек, специфичных для проекта. Такие данные включают в себя пути к данным, файлы для обработки или другие параметры, которые могут изменяться, не требуя изменений в исходном коде.

Пример файла **`config.json`**:
```json
{
  "datasets_dir": "data",
  "file_name": "housing_data.csv",
  "output_dir": "reports"
}
```

- **`datasets_dir`** — путь к директории с данными.
- **`file_name`** — имя конкретного файла для загрузки.
- **`output_dir`** — папка для сохранения результатов работы (например, отчеты, графики).

Файл конфигурации позволяет изменять параметры проекта без изменения самого кода, что очень удобно при масштабировании приложения и изменении входных данных.

### 4. **Простой принцип разворачивания приложения**

Теперь давайте рассмотрим принцип разворачивания приложения, например, для вашего проекта на основе Python.

#### **Шаг 1: Создание виртуального окружения**
Создайте виртуальное окружение для вашего проекта, чтобы изолировать зависимости:

```bash
python3 -m venv myenv
```

#### **Шаг 2: Активируйте виртуальное окружение**
- На Windows:
  ```bash
  myenv\Scripts\activate
  ```
- На macOS и Linux:
  ```bash
  source myenv/bin/activate
  ```

#### **Шаг 3: Установите зависимости**
Установите все библиотеки, указанные в `requirements.txt`:

```bash
pip install -r requirements.txt
```

После этого все необходимые библиотеки (например, `pandas`, `sweetviz`, и другие) будут установлены в вашем виртуальном окружении.

#### **Шаг 4: Подготовьте файл конфигурации**
Убедитесь, что в корневой папке проекта есть файл `config.json`, который содержит актуальные настройки для вашего приложения (пути к файлам, папкам для отчетов и т.д.).

#### **Шаг 5: Запуск приложения**

Теперь, когда все зависимости установлены и настройки указаны в файле `config.json`, вы можете запустить основное приложение. Например, если основной файл вашего проекта называется **`EDAFlow.py`**, то команда для его запуска будет выглядеть так:

Windows:

```bash
python EDAFlow.py --config config.json
```

На MacOS или Linux:

```bash
python3 EDAFlow.py --config config.json
```

**Что происходит при запуске:**
1. Приложение читает конфигурацию из файла **`config.json`**.
2. Используя эти настройки, запускается обработка данных — загрузка, очистка и анализ данных.
3. После выполнения всех этапов генерируется отчет, который сохраняется в директории, указанной в конфигурации.